// Generated by CoffeeScript 1.7.1
var MyModel, model, u,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

u = ABM.util;

MyModel = (function(_super) {
  __extends(MyModel, _super);

  function MyModel() {
    return MyModel.__super__.constructor.apply(this, arguments);
  }

  MyModel.prototype.setup = function() {
    var patch, tree, _i, _j, _len, _ref, _ref1, _results;
    this.agentBreeds("embers fires");
    this.patchBreeds("trees");
    this.agents.setDefault("shape", "square");
    this.agents.setDefault("heading", 0);
    this.fires.setDefault("color", [255, 0, 0]);
    this.default_ember_color = [255, 34, 34];
    this.ash_threshold = 0.5;
    this.embers.setDefault("color", this.ember_default_color);
    this.embers.setDefault("intensity", 1);
    this.ash_color = [34, 34, 34];
    this.trees.setDefault("color", [0, 255, 0]);
    this.trees.setDefault("burnt", false);
    this.refreshPatches = false;
    this.anim.setRate(60, false);

    /*
      Set up options for our simulation:
        - density: percentaje of patches that will be trees
        - ember_decay_rate: rate at which an ember decays and eventually transforms into ash. 
            1 is inmediately, 0 is never. The lower this number is the more embers there will 
            be at any given time, and thus, the slower the animation will be.
     */
    this.density = 100;
    this.ember_decay_rate = 0.01;
    _ref = this.patches;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      patch = _ref[_i];
      if (u.randomInt(100) < this.density) {
        this.trees.setBreed(patch);
      }
    }
    _ref1 = this.trees;
    _results = [];
    for (_j = _ref1.length - 1; _j >= 0; _j += -1) {
      tree = _ref1[_j];
      if (tree.x === this.patches.minX) {
        _results.push(this.ignite(tree));
      }
    }
    return _results;
  };

  MyModel.prototype.ignite = function(tree) {
    tree.sprout(1, this.fires);
    tree.burnt = true;
    tree.color = this.ash_color;
    return tree.draw(this.contexts.patches);
  };

  MyModel.prototype.spread = function(fire) {
    var tree, _i, _len, _ref;
    _ref = fire.p.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      tree = _ref[_i];
      if (tree.breed === this.trees && !tree.burnt) {
        this.ignite(tree);
      }
    }
    return fire.die();
  };

  MyModel.prototype.coolOff = function(ember) {
    ember.intensity *= 1 - this.ember_decay_rate;
    if (ember.intensity < this.ash_threshold) {
      return ember.die();
    } else {
      return ember.color = u.scaleColor(this.default_ember_color, ember.intensity);
    }
  };

  MyModel.prototype.step = function() {
    var fire, _i, _ref;
    if (!this.agents.any()) {
      console.log("..stopping, fire done at tick: " + this.anim.ticks);
      this.stop();
    }
    _ref = this.fires;
    for (_i = _ref.length - 1; _i >= 0; _i += -1) {
      fire = _ref[_i];
      this.spread(fire);
    }
    if (this.anim.ticks % 100 === 0) {
      return console.log(this.anim.toString());
    }
  };

  return MyModel;

})(ABM.Model);

model = new MyModel("layers", 2, -125, 125, -125, 125);

model.debug();

model.start();
