// Generated by CoffeeScript 1.7.1
var Block, GenericBuilding, House, Plot;

Plot = (function() {
  Plot.plots = null;

  Plot.global_id = 0;

  Plot.initialize = function() {
    this.plots = [];
    return this.global_id = 0;
  };

  Plot.make_plot = function(patches) {
    var plot;
    if ((patches != null) && patches.length > 0) {
      plot = new Plot(patches);
      this.plots.push(plot);
      return plot;
    }
  };

  Plot.is_part_of_plot = function(patch) {
    return (patch != null ? patch.plot : void 0) != null;
  };

  Plot.get_random_plot = function() {
    var plot, random_number, total_free_space, _i, _j, _len, _len1, _ref, _ref1;
    if (this.plots.length === 0) {
      return null;
    }
    total_free_space = 0;
    _ref = this.plots;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      plot = _ref[_i];
      total_free_space += plot.free_space();
    }
    random_number = ABM.util.randomInt(total_free_space);
    _ref1 = this.plots;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      plot = _ref1[_j];
      if (!(plot.has_free_space())) {
        continue;
      }
      random_number -= plot.free_space();
      if (random_number <= 0) {
        return plot;
      }
    }
    return null;
  };

  Plot.destroy_plot = function(plot) {
    ABM.util.removeItem(this.plots, plot);
    return plot._unset_block_references();
  };

  Plot.get_available_block = function() {
    var _ref;
    return (_ref = this.get_random_plot()) != null ? _ref.get_available_block() : void 0;
  };

  Plot.prototype.blocks = null;

  Plot.prototype.space = 0;

  Plot.prototype.id = null;

  Plot.prototype.distances = null;

  function Plot(patches) {
    var p, _i, _len;
    this.blocks = [];
    this.under_construction = false;
    this.id = Plot.global_id++;
    for (_i = 0, _len = patches.length; _i < _len; _i++) {
      p = patches[_i];
      if (!Block.is_block(p)) {
        Block.make_here(p, this);
      } else {
        p.plot = this;
      }
      this.blocks.push(p);
    }
  }

  Plot.prototype._unset_block_references = function() {
    var block, _i, _len, _ref, _results;
    _ref = this.blocks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      _results.push(block.plot = null);
    }
    return _results;
  };

  Plot.prototype.get_available_block = function() {
    var block, i, _i, _j, _len, _ref, _ref1, _results;
    _ref1 = ABM.util.shuffle((function() {
      _results = [];
      for (var _j = 0, _ref = this.blocks.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this));
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      block = this.blocks[i];
      if (block.is_available() || House.has_house(block) && block.building.has_free_space()) {
        return this.blocks[i];
      }
    }
    return null;
  };

  Plot.prototype.has_free_space = function() {
    return this.free_space() > 0;
  };

  Plot.prototype.free_space = function() {
    return this.space() - this.citizens();
  };

  Plot.prototype.get_closest_block_to = function(patch) {
    var dist, min_dist, min_patch, p, _i, _len, _ref;
    min_dist = null;
    min_patch = null;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      dist = ABM.util.distance(p.x, p.y, patch.x, patch.y);
      if ((min_dist == null) || dist < min_dist) {
        min_dist = dist;
        min_patch = p;
      }
    }
    return min_patch;
  };

  Plot.prototype.is_available = function() {
    var block, _i, _len, _ref;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (block.is_available()) {
        return true;
      }
    }
    return false;
  };

  Plot.prototype.space = function() {
    var block, sum, _i, _len, _ref;
    sum = 0;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (House.has_house(block) || block.is_available()) {
        sum += House.max_citizens;
      }
    }
    return sum;
  };

  Plot.prototype.citizens = function() {
    var block, sum, _i, _len, _ref;
    sum = 0;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (House.has_house(block)) {
        sum += block.building.citizens;
      }
    }
    return sum;
  };

  return Plot;

})();

CityModel.register_module(Plot, [], []);

Block = (function() {
  function Block() {}

  Block.blocks = null;

  Block.initialize = function(blocks) {
    this.blocks = blocks;
    return House.initialize();
  };

  Block.make_here = function(patch, plot) {
    this.blocks.setBreed(patch);
    extend(patch, Block);
    return patch.init(plot);
  };

  Block.closest_block = function(patch) {
    var closed_list, n, open_list, p, _i, _len, _ref;
    open_list = [patch];
    closed_list = [];
    while (open_list.length > 0) {
      p = open_list.shift();
      if (Block.is_block(p)) {
        return p;
      }
      _ref = p.n4;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (!ABM.util.contains(open_list, n) && !ABM.util.contains(closed_list, n)) {
          open_list.push(n);
        }
      }
      closed_list.push(p);
    }
    return null;
  };

  Block.is_block = function(patch) {
    return patch.breed === this.blocks;
  };

  Block.prototype.plot = null;

  Block.prototype.building = null;

  Block.prototype.init = function(plot) {
    this.plot = plot;
    this.color = ABM.util.randomGray(140, 170);
    return this.distances = {};
  };

  Block.prototype.destroy = function() {
    return CityModel.get_patches().setBreed(this);
  };

  Block.prototype.is_available = function() {
    return this.building == null;
  };

  Block.prototype.building_type = function() {
    var _ref;
    return (_ref = this.building) != null ? _ref._building_type : void 0;
  };

  Block.prototype.is_of_type = function(type) {
    return this.building_type() === type;
  };

  Block.prototype.dist_to_need = function(need) {
    if (need in this.distances) {
      return this.distances[need];
    } else {
      return null;
    }
  };

  Block.prototype.set_dist_to_need = function(need, dist) {
    return this.distances[need] = dist;
  };

  Block.prototype._manhatan_distance_to = function(patch) {
    return Math.abs(this.x - patch.x) + Math.abs(this.y - patch.y);
  };

  return Block;

})();

CityModel.register_module(Block, [], ['blocks']);

House = (function() {
  House.default_color = [100, 0, 0];

  House.max_citizens = 10;

  House.minimum_housing_available = 0.5;

  House.explansion_threshold = 0.5;

  House.explansion_factor = 1.25;

  House.population = 0;

  House.initialize = function() {
    return this.population = 0;
  };

  House.get_or_create = function(block) {
    var house;
    house = null;
    if (Block.is_block(block)) {
      if (House.has_house(block)) {
        house = block.building;
      } else if (block.is_available()) {
        house = House.make_here(block);
      }
    }
    return house;
  };

  House.make_here = function(block) {
    if (Block.is_block(block)) {
      block.building = new House(block);
      return block.building;
    }
  };

  House.has_house = function(patch) {
    return Block.is_block(patch) && patch.is_of_type('house');
  };

  House.houses_below_minimum = function() {
    var block, free_space, total_space, _i, _len, _ref;
    free_space = 0;
    total_space = 0;
    _ref = Block.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (!(House.has_house(block))) {
        continue;
      }
      total_space += block.house.space;
      free_space += block.house.free_space();
    }
    return (free_space / total_space) < House.minimum_housing_available;
  };

  House._update_navigation = function(house) {};

  House.get_available_block = function() {};

  House.prototype._building_type = 'house';

  House.prototype.color = [100, 0, 0];

  House.prototype.blocks = null;

  House.prototype.citizens = 0;

  House.prototype.space = House.max_citizens;

  function House(block) {
    this.blocks = [];
    this.blocks.push(block);
    House._update_navigation(this);
    block.color = this.color;
  }

  House.prototype.has_free_space = function() {
    return this.citizens < this.space;
  };

  House.prototype.free_space = function() {
    return this.space - this.citizens;
  };

  House.prototype.increase_citizens = function() {
    if (this.has_free_space()) {
      this.citizens += 1;
      House.population += 1;
      this.blocks[0].color = ABM.util.scaleColor(this.blocks[0].color, 1.05);
      return this._check_for_expansion();
    }
  };

  House.prototype.reallocate_citizens = function() {
    var i, _i, _ref, _results;
    _results = [];
    for (i = _i = 0, _ref = this.citizens; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      House.population -= 1;
      _results.push(HouseBuilder.spawn_house_builder(this.blocks[0], Plot.get_available_block()));
    }
    return _results;
  };

  House.prototype._check_for_expansion = function() {};

  House.prototype.is_1x1 = function() {
    return this.blocks.length === 1;
  };

  House.prototype.is_2x1 = function() {
    return this.blocks.length === 2;
  };

  House.prototype.is_2x2 = function() {
    return this.blocks.length === 4;
  };

  House.prototype._check_2x1 = function() {
    var block, _i, _len, _ref, _results;
    if (this.is_1x1()) {
      _ref = this.block.n4;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (House.has_house(block)) {
          if (block.house.is_1x1()) {
            _results.push(1);
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    }
  };

  return House;

})();

GenericBuilding = (function() {
  GenericBuilding.info = {
    hospital: {
      threshold: 400,
      radius: 20,
      color: [223, 194, 24]
    },
    school: {
      threshold: 100,
      radius: 10,
      color: [223, 194, 24]
    },
    store: {
      threshold: 50,
      radius: 5,
      color: [223, 194, 24]
    }
  };

  GenericBuilding.make_here = function(block, subtype) {
    if (Block.is_block(block)) {
      if (House.has_house(block)) {
        block.building.reallocate_citizens();
      }
      return block.building = new GenericBuilding(block, subtype);
    }
  };

  GenericBuilding.is_building = function(patch) {
    return Block.is_block(patch) && patch.is_of_type('building');
  };

  GenericBuilding.get_of_subtype = function(subtype) {
    var block;
    return (function() {
      var _i, _len, _ref, _results;
      _ref = Block.blocks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (block.is_of_type('building') && block.building.is_of_subtype(subtype)) {
          _results.push(block);
        }
      }
      return _results;
    })();
  };

  GenericBuilding.prototype._building_type = 'building';

  GenericBuilding.prototype.building_subtype = null;

  GenericBuilding.prototype.color = [174, 131, 0];

  function GenericBuilding(block, building_subtype) {
    this.building_subtype = building_subtype;
    this.blocks = [];
    this.blocks.push(block);
    this._set_distances();
    if (this.building_subtype === 'hospital') {
      block.color = this.color;
    } else if (this.building_subtype === 'school') {
      block.color = [181, 49, 255];
    } else {
      block.color = [0, 255, 249];
    }
  }

  GenericBuilding.prototype._set_distances = function() {
    var block, block_dist, blocks_in_radius, m_dist, _i, _len, _results;
    blocks_in_radius = Block.blocks.inRadius(this.blocks[0], 10);
    _results = [];
    for (_i = 0, _len = blocks_in_radius.length; _i < _len; _i++) {
      block = blocks_in_radius[_i];
      if (!(House.has_house(block))) {
        continue;
      }
      m_dist = this.blocks[0]._manhatan_distance_to(block);
      block_dist = block.dist_to_need(this.building_subtype);
      if ((block_dist == null) || block_dist > m_dist) {
        _results.push(block.set_dist_to_need(this.building_subtype, m_dist));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  GenericBuilding.prototype.is_of_subtype = function(subtype) {
    return this.building_subtype === subtype;
  };

  return GenericBuilding;

})();
