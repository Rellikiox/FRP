// Generated by CoffeeScript 1.7.1
var Block, Building, House, Plot;

Plot = (function() {
  Plot.plots = null;

  Plot.initialize = function() {
    return this.plots = [];
  };

  Plot.make_plot = function(patches) {
    var plot;
    if ((patches != null) && patches.length > 0) {
      plot = new Plot(patches);
      this.plots.push(plot);
      return plot;
    }
  };

  Plot.is_part_of_plot = function(patch) {
    return (patch != null ? patch.plot : void 0) != null;
  };

  Plot.get_random_plot = function() {
    var plot, random_number, total_free_space, _i, _j, _len, _len1, _ref, _ref1;
    if (this.plots.length === 0) {
      return null;
    }
    total_free_space = 0;
    _ref = this.plots;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      plot = _ref[_i];
      total_free_space += plot.free_space();
    }
    random_number = ABM.util.randomInt(total_free_space);
    _ref1 = this.plots;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      plot = _ref1[_j];
      random_number -= plot.free_space();
      if (random_number <= 0) {
        return plot;
      }
    }
    return null;
  };

  Plot.destroy_plot = function(plot) {
    ABM.util.removeItem(this.plots, plot);
    return plot._unset_block_references();
  };

  Plot.get_available_block = function() {
    var _ref;
    return (_ref = this.get_random_plot()) != null ? _ref.get_available_block() : void 0;
  };

  Plot.prototype.blocks = null;

  Plot.prototype.space = 0;

  function Plot(patches) {
    var p, _i, _len;
    this.blocks = [];
    this.under_construction = false;
    for (_i = 0, _len = patches.length; _i < _len; _i++) {
      p = patches[_i];
      if (!Block.is_block(p)) {
        Block.make_here(p, this);
      } else {
        p.plot = this;
      }
      this.blocks.push(p);
    }
  }

  Plot.prototype._unset_block_references = function() {
    var block, _i, _len, _ref, _results;
    _ref = this.blocks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      _results.push(block.plot = null);
    }
    return _results;
  };

  Plot.prototype.get_available_block = function() {
    var block, i, _i, _j, _len, _ref, _ref1, _results;
    _ref1 = ABM.util.shuffle((function() {
      _results = [];
      for (var _j = 0, _ref = this.blocks.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; 0 <= _ref ? _j++ : _j--){ _results.push(_j); }
      return _results;
    }).apply(this));
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      i = _ref1[_i];
      block = this.blocks[i];
      if (block.is_available() || House.is_house(block) && block.has_free_space()) {
        return this.blocks[i];
      }
    }
    return null;
  };

  Plot.prototype.has_free_space = function() {
    return this.get_available_block() != null;
  };

  Plot.prototype.free_space = function() {
    return this.space() - this.citizens();
  };

  Plot.prototype.get_closest_block_to = function(patch) {
    var dist, min_dist, min_patch, p, _i, _len, _ref;
    min_dist = null;
    min_patch = null;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      p = _ref[_i];
      dist = ABM.util.distance(p.x, p.y, patch.x, patch.y);
      if ((min_dist == null) || dist < min_dist) {
        min_dist = dist;
        min_patch = p;
      }
    }
    return min_patch;
  };

  Plot.prototype.is_available = function() {
    var block, _i, _len, _ref;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (block.is_available()) {
        return true;
      }
    }
    return false;
  };

  Plot.prototype.space = function() {
    var block, sum, _i, _len, _ref;
    sum = 0;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (House.is_house(block) || block.is_available()) {
        sum += House.max_citizens;
      }
    }
    return sum;
  };

  Plot.prototype.citizens = function() {
    var block, sum, _i, _len, _ref;
    sum = 0;
    _ref = this.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      block = _ref[_i];
      if (House.is_house(block)) {
        sum += block.citizens;
      }
    }
    return sum;
  };

  return Plot;

})();

CityModel.register_module(Plot, [], []);

Block = (function() {
  function Block() {}

  Block.blocks = null;

  Block.initialize = function(blocks) {
    this.blocks = blocks;
  };

  Block.make_here = function(patch, plot) {
    this.blocks.setBreed(patch);
    extend(patch, Block);
    return patch.init(plot);
  };

  Block.closest_block = function(patch) {
    var closed_list, n, open_list, p, _i, _len, _ref;
    open_list = [patch];
    closed_list = [];
    while (open_list.length > 0) {
      p = open_list.shift();
      if (Block.is_block(p)) {
        return p;
      }
      _ref = p.n4;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (!ABM.util.contains(open_list, n) && !ABM.util.contains(closed_list, n)) {
          open_list.push(n);
        }
      }
      closed_list.push(p);
    }
    return null;
  };

  Block.is_block = function(patch) {
    return patch.breed === this.blocks;
  };

  Block.prototype.plot = null;

  Block.prototype.block_type = 'block';

  Block.prototype.init = function(plot) {
    this.plot = plot;
    return this.color = ABM.util.randomGray(140, 170);
  };

  Block.prototype.destroy = function() {
    return CityModel.get_patches().setBreed(this);
  };

  Block.prototype.is_available = function() {
    return this.block_type === 'block';
  };

  return Block;

})();

CityModel.register_module(Block, [], ['blocks']);

House = (function() {
  function House() {}

  House.default_color = [100, 0, 0];

  House.max_citizens = 10;

  House.minimum_housing_available = 0.5;

  House.total_citizens = 0;

  House.make_here = function(block) {
    if (Block.is_block(block)) {
      extend(block, House);
      return block.init();
    }
  };

  House.is_house = function(patch) {
    return Block.is_block(patch) && patch.block_type === 'house';
  };

  House.houses_below_minimum = function() {
    var free_space, house, total_space, _i, _len, _ref;
    free_space = 0;
    total_space = 0;
    _ref = Block.blocks;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      house = _ref[_i];
      if (!(house.block_type === 'house')) {
        continue;
      }
      total_space += house.space;
      free_space += house.free_space();
    }
    return (free_space / total_space) < House.minimum_housing_available;
  };

  House._update_navigation = function(house) {};

  House.get_available_block = function() {};

  House.prototype.block_type = 'house';

  House.prototype.color = [100, 0, 0];

  House.prototype.citizens = 0;

  House.prototype.space = 0;

  House.prototype.init = function() {
    House._update_navigation(this);
    this.citizens = 0;
    this.space = House.max_citizens;
    this.inspector = Inspector.spawn_house_inspector(this);
    return this.board = MessageBoard.get_board('new_citizen');
  };

  House.prototype.has_free_space = function() {
    return this.citizens < this.space;
  };

  House.prototype.free_space = function() {
    return this.space - this.citizens;
  };

  House.prototype.increase_citizens = function() {
    if (this.has_free_space()) {
      this.citizens += 1;
      House.total_citizens += 1;
      return this.color = ABM.util.scaleColor(this.color, 1.05);
    }
  };

  House.prototype.reallocate_citizens = function() {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.citizens; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      HouseBuilder.spawn_house_builder(this, Plot.get_available_block());
    }
    return this.inspector.die();
  };

  return House;

})();

Building = (function() {
  function Building() {}

  Building.make_here = function(block, type) {
    if (Block.is_block(block)) {
      if (House.is_house(block)) {
        block.reallocate_citizens();
      }
      extend(block, Building);
      return block.init(type);
    }
  };

  Building.is_building = function(patch) {
    return Block.is_block(patch) && patch.block_type === 'building';
  };

  Building.get_of_type = function(type) {
    var block;
    return (function() {
      var _i, _len, _ref, _results;
      _ref = Block.blocks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        block = _ref[_i];
        if (this.is_building(block) && block.building_type === type) {
          _results.push(block);
        }
      }
      return _results;
    }).call(this);
  };

  Building.prototype.block_type = 'building';

  Building.prototype.building_type = null;

  Building.prototype.color = [174, 131, 0];

  Building.prototype.init = function(building_type) {
    this.building_type = building_type;
  };

  return Building;

})();
