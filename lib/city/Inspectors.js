// Generated by CoffeeScript 1.7.1
var Inspector, LotInspector, NodeInspector, RoadInspector,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Inspector = (function() {
  function Inspector() {}

  Inspector.inspectors = null;

  Inspector.default_color = [0, 0, 255];

  Inspector.initialize_module = function(inspectors_breed, config) {
    var key, value, _ref, _ref1;
    this.inspectors = inspectors_breed;
    this.inspectors.setDefault('color', this.default_color);
    RoadInspector.construction_points = [];
    _ref = config.node_inspector;
    for (key in _ref) {
      value = _ref[key];
      NodeInspector.prototype[key] = value;
    }
    _ref1 = config.road_inspector;
    for (key in _ref1) {
      value = _ref1[key];
      RoadInspector.prototype[key] = value;
    }
    return null;
  };

  Inspector.spawn_road_inspector = function(patch) {
    return this.spawn_inspector(patch, RoadInspector);
  };

  Inspector.spawn_node_inspector = function(patch) {
    return this.spawn_inspector(patch, NodeInspector);
  };

  Inspector.spawn_lot_inspector = function(patch) {
    return this.spawn_inspector(patch, LotInspector);
  };

  Inspector.spawn_inspector = function(patch, klass) {
    var inspector;
    inspector = patch.sprout(1, this.inspectors)[0];
    extend(inspector, FSMAgent, MovingAgent, klass);
    inspector.init();
    return inspector;
  };

  Inspector.prototype.speed = 0.05;

  Inspector.prototype.test = 1;

  return Inspector;

})();

NodeInspector = (function(_super) {
  __extends(NodeInspector, _super);

  function NodeInspector() {
    return NodeInspector.__super__.constructor.apply(this, arguments);
  }

  NodeInspector.prototype.current_message = null;

  NodeInspector.prototype.nodes_under_investigation = [];

  NodeInspector.prototype.inspection_radius = 20;

  NodeInspector.prototype.max_distance_factor = 3;

  NodeInspector.prototype.init = function() {
    this._set_initial_state('get_message');
    return this.msg_boards = {
      inspect: MessageBoard.get_board('node_built'),
      connect: MessageBoard.get_board('nodes_unconnected')
    };
  };

  NodeInspector.prototype.s_get_message = function() {
    this.current_message = this.msg_boards.inspect.get_message();
    if (this.current_message != null) {
      return this._set_state('go_to_endpoint');
    }
  };

  NodeInspector.prototype.s_go_to_endpoint = function() {
    if (this.path == null) {
      this.path = CityModel.instance.roadAStar.getPath(this, this.current_message.patch);
    }
    this._move(this.path[0]);
    if (this._in_point(this.path[0])) {
      this.path.shift();
      if (this.path.length === 0) {
        this.path = null;
        this.nodes_under_investigation = this._get_close_nodes();
        return this._set_state('inspect_endpoint');
      }
    }
  };

  NodeInspector.prototype.s_inspect_endpoint = function() {
    var node_connected;
    node_connected = this._inspect_node(this.nodes_under_investigation.shift());
    if (node_connected || this.nodes_under_investigation.length === 0) {
      this.nodes_under_investigation = [];
      this.current_message = null;
      return this._set_state('get_message');
    }
  };

  NodeInspector.prototype._inspect_node = function(node) {
    if (node.factor > this.max_distance_factor) {
      this.msg_boards.connect.post_message({
        patch_a: this.p,
        patch_b: node.node.p
      });
      return true;
    }
    return false;
  };

  NodeInspector.prototype._get_close_nodes = function() {
    var factor, node, nodes, nodes_to_check, _i, _len;
    nodes = [];
    if (this.p.node != null) {
      nodes_to_check = RoadNode.road_nodes.inRadius(this.p.node, this.inspection_radius);
    } else {
      nodes_to_check = RoadNode.road_nodes.inRadius(this, this.inspection_radius);
    }
    for (_i = 0, _len = nodes_to_check.length; _i < _len; _i++) {
      node = nodes_to_check[_i];
      factor = this._get_node_distance_factor(node);
      nodes.push({
        node: node,
        factor: factor
      });
    }
    nodes.sort(function(a, b) {
      if (a.factor < b.factor) {
        return 1;
      } else {
        return -1;
      }
    });
    return nodes;
  };

  NodeInspector.prototype._get_node_distance_factor = function(node) {
    var factor, real_dist, road_dist;
    real_dist = this.distance(node);
    road_dist = Road.get_road_distance(this, node);
    return factor = road_dist / real_dist;
  };

  return NodeInspector;

})(Inspector);

RoadInspector = (function(_super) {
  __extends(RoadInspector, _super);

  function RoadInspector() {
    return RoadInspector.__super__.constructor.apply(this, arguments);
  }

  RoadInspector.prototype.ring_increment = 4;

  RoadInspector.prototype.ring_radius = 6;

  RoadInspector.prototype.init = function() {
    this._set_initial_state('get_inspection_point');
    return this.build_endpoint_board = MessageBoard.get_board('possible_node');
  };

  RoadInspector.prototype.s_get_inspection_point = function() {
    this.inspection_point = this._get_point_to_inspect();
    if (this.inspection_point != null) {
      return this._set_state('go_to_inspection_point');
    }
  };

  RoadInspector.prototype.s_go_to_inspection_point = function() {
    if (this.inspection_point == null) {
      this._set_state('get_inspection_point');
      return;
    }
    this._move(this.inspection_point);
    if (this._in_point(this.inspection_point)) {
      return this._set_state('find_new_endpoint');
    }
  };

  RoadInspector.prototype.s_find_new_endpoint = function() {
    if (this._is_valid_construction_point(this.p)) {
      this._issue_construction(this.p);
      return this._set_state('get_inspection_point');
    } else {
      return this._set_state('get_away_from_road');
    }
  };

  RoadInspector.prototype.s_get_away_from_road = function() {
    if (this.circular_direction == null) {
      this.angle_moved = 0;
      this.circular_direction = ABM.util.oneOf([-1, 1]);
    }
    this._circular_move();
    if (this._is_valid_construction_point(this.p)) {
      this.circular_direction = null;
      this.angle_moved = 0;
      this._set_state('find_new_endpoint');
    }
    if (this._lap_completed()) {
      this.circular_direction = null;
      this.start_angle = null;
      this.ring_radius += this.ring_increment;
      return this._set_state('get_inspection_point');
    }
  };

  RoadInspector.prototype._get_point_to_inspect = function() {
    var rand_angle, x, y;
    rand_angle = ABM.util.randomFloat(2 * Math.PI);
    x = Math.round(this.ring_radius * Math.cos(rand_angle));
    y = Math.round(this.ring_radius * Math.sin(rand_angle));
    return {
      x: x,
      y: y
    };
  };

  RoadInspector.prototype._circular_move = function() {
    var angle, angle_increment, point, polar_coords;
    polar_coords = this._get_polar_coords();
    angle_increment = (this.speed / polar_coords.radius) * this.circular_direction;
    this.angle_moved += Math.abs(angle_increment);
    angle = polar_coords.angle + angle_increment;
    point = this._point_from_polar_coords(polar_coords.radius, angle);
    return this._move(point);
  };

  RoadInspector.prototype._point_from_polar_coords = function(radius, angle) {
    var point;
    point = {
      x: radius * Math.cos(angle),
      y: radius * Math.sin(angle)
    };
    return point;
  };

  RoadInspector.prototype._get_polar_coords = function() {
    var polar_coords;
    polar_coords = {
      angle: Math.atan2(this.y, this.x),
      radius: ABM.util.distance(0, 0, this.x, this.y)
    };
    return polar_coords;
  };

  RoadInspector.prototype._is_valid_construction_point = function(patch) {
    var construction_dist, road_dist;
    road_dist = Road.get_connectivity(this.p);
    construction_dist = this._get_construction_dist(this.p);
    return road_dist > 2 && ((construction_dist == null) || construction_dist > 2);
  };

  RoadInspector.prototype._issue_construction = function(patch) {
    this.constructor.construction_points.push(patch);
    return this.build_endpoint_board.post_message({
      patch: patch
    });
  };

  RoadInspector.prototype._get_construction_dist = function(patch) {
    var dist_to_point, min_dist, point, _i, _len, _ref;
    min_dist = null;
    _ref = this.constructor.construction_points;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      point = _ref[_i];
      dist_to_point = ABM.util.distance(patch.x, patch.y, point.x, point.y);
      if ((min_dist == null) || dist_to_point < min_dist) {
        min_dist = dist_to_point;
      }
    }
    return min_dist;
  };

  RoadInspector.prototype._lap_completed = function() {
    return this.angle_moved >= 2 * Math.PI;
  };

  return RoadInspector;

})(Inspector);

LotInspector = (function() {
  function LotInspector() {}

  LotInspector.prototype.init = function() {
    this._set_initial_state('get_message');
    this.patches_to_check = [];
    return this.msg_boards = {
      inspect: MessageBoard.get_board('inspect_lot'),
      built: MessageBoard.get_board('lot_built')
    };
  };

  LotInspector.prototype.s_get_message = function() {
    this.current_message = this.msg_boards.inspect.get_message();
    if (this.current_message != null) {
      this.inspection_point = this.current_message.patch;
      return this._set_state('go_to_point');
    }
  };

  LotInspector.prototype.s_go_to_point = function() {
    if (this.inspection_point == null) {
      this._set_state('s_get_message');
      return;
    }
    this._move(this.inspection_point);
    if (this._in_point(this.inspection_point)) {
      return this._set_state('check_possible_lots');
    }
  };

  LotInspector.prototype.s_check_possible_lots = function() {
    if (this.patches_to_check.length === 0) {
      this.patches_to_check = this._get_patches_to_check();
    }
    this._check_patch(this.patches_to_check.shift());
    if (this.patches_to_check.length === 0) {
      return this._set_state('get_message');
    }
  };

  LotInspector.prototype._get_patches_to_check = function() {
    var i, invalid, j, p, patches, _i, _j, _ref, _ref1;
    patches = (function() {
      var _i, _len, _ref, _results;
      _ref = this.p.n;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (!Road.is_road(p)) {
          _results.push(p);
        }
      }
      return _results;
    }).call(this);
    invalid = [];
    for (i = _i = _ref = patches.length - 1; _i >= 0; i = _i += -1) {
      for (j = _j = 0, _ref1 = patches.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
        if (i === j) {
          break;
        }
        if (this._adyacent(patches[i], patches[j])) {
          invalid.push(patches[j]);
        }
      }
    }
    return (function() {
      var _k, _len, _results;
      _results = [];
      for (_k = 0, _len = patches.length; _k < _len; _k++) {
        p = patches[_k];
        if (!ABM.util.contains(invalid, p)) {
          _results.push(p);
        }
      }
      return _results;
    })();
  };

  LotInspector.prototype._adyacent = function(patch_a, patch_b) {
    var adyacent, horizontal;
    horizontal = Math.abs(patch_a.x - patch_b.x) === 1 && patch_a.y === patch_b.y;
    adyacent = horizontal || patch_a.x === patch_b.x && Math.abs(patch_a.y - patch_b.y) === 1;
    return adyacent;
  };

  LotInspector.prototype._check_patch = function(patch) {
    var possible_lot;
    if (!this._any_edge_visible(patch)) {
      possible_lot = this._get_lot(patch);
      if (possible_lot != null) {
        return this.msg_boards.built.post_message({
          lot: possible_lot
        });
      }
    }
  };

  LotInspector.prototype._any_edge_visible = function(patch) {
    var current_patch, edge, offset, offsets, _i, _len;
    current_patch = patch;
    offsets = [
      {
        x: 0,
        y: 1
      }, {
        x: 1,
        y: 0
      }, {
        x: 0,
        y: -1
      }, {
        x: -1,
        y: 0
      }
    ];
    edge = false;
    for (_i = 0, _len = offsets.length; _i < _len; _i++) {
      offset = offsets[_i];
      current_patch = patch;
      while (!edge) {
        current_patch = this._get_path_with_offset(current_patch, offset);
        if (Road.is_road(current_patch)) {
          break;
        }
        if (current_patch.isOnEdge()) {
          edge = true;
        }
      }
      if (edge) {
        break;
      }
    }
    return edge;
  };

  LotInspector.prototype._get_path_with_offset = function(patch, offset) {
    var point;
    point = {
      x: patch.x + offset.x,
      y: patch.y + offset.y
    };
    return CityModel.get_patch_at(point);
  };

  LotInspector.prototype._get_lot = function(patch) {};

  return LotInspector;

})();
