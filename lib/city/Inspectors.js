// Generated by CoffeeScript 1.7.1
define(['city/Common', 'city/MessageBoard'], function(Common, MessageBoard) {
  var InspectorManager, NodeInspector, Road, RoadInspector, RoadNode;
  console.log("Loaded city/Inspector.coffee");
  Road = null;
  RoadNode = null;
  InspectorManager = (function() {
    InspectorManager.inspector_breed = 'inspectors';

    InspectorManager.prototype.inspectors = null;

    InspectorManager.prototype.road_manager = null;

    InspectorManager.prototype.default_color = [0, 0, 255];

    function InspectorManager(inspectors, road_manager, road_node_manager) {
      this.inspectors = inspectors;
      this.inspectors.setDefault('color', this.default_color);
      Road = road_manager;
      RoadNode = road_node_manager;
    }

    InspectorManager.prototype.spawn_road_inspector = function(patch) {
      return this.spawn_inspector(patch, RoadInspector.prototype);
    };

    InspectorManager.prototype.spawn_node_inspector = function(patch) {
      return this.spawn_inspector(patch, NodeInspector.prototype);
    };

    InspectorManager.prototype.spawn_inspector = function(patch, prototype) {
      var inspector;
      inspector = patch.sprout(1, this.inspectors)[0];
      Common.extend(inspector, Common.BaseAgent.prototype);
      Common.extend(inspector, prototype);
      inspector.init();
      return inspector;
    };

    return InspectorManager;

  })();
  NodeInspector = (function() {
    function NodeInspector() {}

    NodeInspector.prototype.current_message = null;

    NodeInspector.prototype.nodes_under_investigation = [];

    NodeInspector.prototype.speed = 0.05;

    NodeInspector.prototype.init = function() {
      this._set_state('get_message');
      return this.msg_boards = {
        inspect: MessageBoard.get_board('inspect_endpoint'),
        connect: MessageBoard.get_board('connect_nodes')
      };
    };

    NodeInspector.prototype.s_get_message = function() {
      this.current_message = this.msg_boards.inspect.get_message();
      if (this.current_message != null) {
        this.path = CityModel.instance.roadAStar.getPath(this, this.current_message.patch);
        return this._set_state('go_to_endpoint');
      }
    };

    NodeInspector.prototype.s_go_to_endpoint = function() {
      this._move(this.path[0]);
      if (this._in_point(this.path[0])) {
        this.path.shift();
        if (this.path.length === 0) {
          this.path = null;
          this.nodes_under_investigation = this._get_close_nodes();
          return this._set_state('inspect_endpoint');
        }
      }
    };

    NodeInspector.prototype.s_inspect_endpoint = function() {
      var node_connected;
      node_connected = this._inspect_node(this.nodes_under_investigation.shift());
      if (node_connected || this.nodes_under_investigation.length === 0) {
        this.nodes_under_investigation = [];
        this.current_message = null;
        return this._set_state('get_message');
      }
    };

    NodeInspector.prototype._inspect_node = function(node) {
      if (node.factor > 3) {
        this.msg_boards.connect.post_message({
          patch_a: this.p,
          patch_b: node.node.p
        });
        return true;
      }
      return false;
    };

    NodeInspector.prototype._get_close_nodes = function() {
      var factor, node, nodes, nodes_to_check, _i, _len;
      nodes = [];
      if (this.p.node != null) {
        nodes_to_check = RoadNode.road_nodes.inRadius(this.p.node, 20);
      } else {
        nodes_to_check = RoadNode.road_nodes.inRadius(this, 20);
      }
      for (_i = 0, _len = nodes_to_check.length; _i < _len; _i++) {
        node = nodes_to_check[_i];
        factor = this._get_node_distance_factor(node);
        nodes.push({
          node: node,
          factor: factor
        });
      }
      nodes.sort(function(a, b) {
        if (a.factor < b.factor) {
          return 1;
        } else {
          return -1;
        }
      });
      return nodes;
    };

    NodeInspector.prototype._get_node_distance_factor = function(node) {
      var factor, real_dist, road_dist;
      real_dist = this.distance(node);
      road_dist = Road.get_road_distance(this, node);
      return factor = road_dist / real_dist;
    };

    return NodeInspector;

  })();
  RoadInspector = (function() {
    function RoadInspector() {}

    RoadInspector.construction_points = [];

    RoadInspector.prototype.speed = 0.05;

    RoadInspector.prototype.ring_increment = 4;

    RoadInspector.prototype.ring_radius = 6;

    RoadInspector.prototype.init = function() {
      this._set_state('get_inspection_point');
      return this.build_endpoint_board = MessageBoard.get_board('build_endpoint');
    };

    RoadInspector.prototype.s_get_inspection_point = function() {
      this.inspection_point = this._get_point_to_inspect();
      if (this.inspection_point != null) {
        return this._set_state('go_to_inspection_point');
      }
    };

    RoadInspector.prototype.s_go_to_inspection_point = function() {
      if (this.inspection_point == null) {
        this._set_state('get_inspection_point');
        return;
      }
      this._move(this.inspection_point);
      if (this._in_point(this.inspection_point)) {
        return this._set_state('find_new_endpoint');
      }
    };

    RoadInspector.prototype.s_find_new_endpoint = function() {
      if (this._is_valid_construction_point(this.p)) {
        this._issue_construction(this.p);
        return this._set_state('get_inspection_point');
      } else {
        return this._set_state('get_away_from_road');
      }
    };

    RoadInspector.prototype.s_get_away_from_road = function() {
      if (this.circular_direction == null) {
        this.angle_moved = 0;
        this.circular_direction = ABM.util.oneOf([-1, 1]);
      }
      this._circular_move();
      if (this._is_valid_construction_point(this.p)) {
        this.circular_direction = null;
        this.angle_moved = 0;
        this._set_state('find_new_endpoint');
      }
      if (this._lap_completed()) {
        this.circular_direction = null;
        this.start_angle = null;
        this.ring_radius += this.ring_increment;
        return this._set_state('get_inspection_point');
      }
    };

    RoadInspector.prototype._get_point_to_inspect = function() {
      var rand_angle, x, y;
      rand_angle = ABM.util.randomFloat(2 * Math.PI);
      x = Math.round(this.ring_radius * Math.cos(rand_angle));
      y = Math.round(this.ring_radius * Math.sin(rand_angle));
      return {
        x: x,
        y: y
      };
    };

    RoadInspector.prototype._circular_move = function() {
      var angle, angle_increment, point, polar_coords;
      polar_coords = this._get_polar_coords();
      angle_increment = (this.speed / polar_coords.radius) * this.circular_direction;
      this.angle_moved += Math.abs(angle_increment);
      angle = polar_coords.angle + angle_increment;
      point = this._point_from_polar_coords(polar_coords.radius, angle);
      return this._move(point);
    };

    RoadInspector.prototype._point_from_polar_coords = function(radius, angle) {
      var point;
      point = {
        x: radius * Math.cos(angle),
        y: radius * Math.sin(angle)
      };
      return point;
    };

    RoadInspector.prototype._get_polar_coords = function() {
      var polar_coords;
      polar_coords = {
        angle: Math.atan2(this.y, this.x),
        radius: ABM.util.distance(0, 0, this.x, this.y)
      };
      return polar_coords;
    };

    RoadInspector.prototype._is_valid_construction_point = function(patch) {
      var construction_dist, road_dist;
      road_dist = Road.get_connectivity(this.p);
      construction_dist = this._get_construction_dist(this.p);
      return road_dist > 2 && ((construction_dist == null) || construction_dist > 2);
    };

    RoadInspector.prototype._issue_construction = function(patch) {
      this.constructor.construction_points.push(patch);
      return this.build_endpoint_board.post_message({
        patch: patch
      });
    };

    RoadInspector.prototype._get_construction_dist = function(patch) {
      var dist_to_point, min_dist, point, _i, _len, _ref;
      min_dist = null;
      _ref = this.constructor.construction_points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        dist_to_point = ABM.util.distance(patch.x, patch.y, point.x, point.y);
        if ((min_dist == null) || dist_to_point < min_dist) {
          min_dist = dist_to_point;
        }
      }
      return min_dist;
    };

    RoadInspector.prototype._lap_completed = function() {
      return this.angle_moved >= 2 * Math.PI;
    };

    return RoadInspector;

  })();
  return InspectorManager;
});
