// Generated by CoffeeScript 1.7.1
var KMeans;

KMeans = (function() {
  KMeans.max_iters = 100;

  KMeans._copy_point = function(point) {
    return {
      x: point.x,
      y: point.y
    };
  };

  KMeans._init_centroids = function(points, number_of_clusters) {
    var centroids, i, index, _i;
    centroids = [];
    for (i = _i = 0; 0 <= number_of_clusters ? _i < number_of_clusters : _i > number_of_clusters; i = 0 <= number_of_clusters ? ++_i : --_i) {
      index = ABM.util.randomInt(points.length);
      centroids.push({
        point: KMeans._copy_point(points[index]),
        points: []
      });
    }
    return centroids;
  };

  KMeans._dist = function(point_a, point_b) {
    return ABM.util.distance(point_a.x, point_a.y, point_b.x, point_b.y);
  };

  KMeans._closest_centroid = function(distances) {
    return ABM.util.minOneOf(distances, function(point) {
      return point.distance;
    }).centroid;
  };

  KMeans._points_are_equal = function(point_a, point_b) {
    return this._dist(point_a, point_b) < 0.1;
  };

  function KMeans(points, number_of_clusters) {
    this.points = points;
    this.number_of_clusters = number_of_clusters;
    this.centroids = KMeans._init_centroids(this.points, this.number_of_clusters);
    this.converged = false;
  }

  KMeans.prototype.run = function() {
    var iters, _results;
    iters = 0;
    _results = [];
    while (!this.converged && iters < KMeans.max_iters) {
      this.step();
      _results.push(iters += 1);
    }
    return _results;
  };

  KMeans.prototype.step = function() {
    this.assign_centroids();
    return this.converged = this.move_centroids();
  };

  KMeans.prototype.assign_centroids = function() {
    var centroid, distances, point, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = this.centroids;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      centroid = _ref[_i];
      centroid.points = [];
    }
    _ref1 = this.points;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      point = _ref1[_j];
      distances = (function() {
        var _k, _len2, _ref2, _results1;
        _ref2 = this.centroids;
        _results1 = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          centroid = _ref2[_k];
          _results1.push({
            distance: KMeans._dist(point, centroid.point),
            centroid: centroid
          });
        }
        return _results1;
      }).call(this);
      _results.push(KMeans._closest_centroid(distances).points.push(point));
    }
    return _results;
  };

  KMeans.prototype.move_centroids = function() {
    var centroid, mean_position, moved, point, _i, _j, _len, _len1, _ref, _ref1;
    moved = false;
    _ref = this.centroids;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      centroid = _ref[_i];
      mean_position = {
        x: 0,
        y: 0
      };
      _ref1 = centroid.points;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        point = _ref1[_j];
        mean_position.x += point.x;
        mean_position.y += point.y;
      }
      mean_position.x /= centroid.points.length;
      mean_position.y /= centroid.points.length;
      moved |= !KMeans._points_are_equal(centroid.point, mean_position);
      centroid.point = mean_position;
    }
    return moved;
  };

  return KMeans;

})();
