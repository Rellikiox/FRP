// Generated by CoffeeScript 1.7.1
var Road, RoadNode;

Road = (function() {
  function Road() {}

  Road.roads = null;

  Road.default_color = [80, 80, 80];

  Road.too_connected_threshold = 2;

  Road.initialize = function(roads) {
    this.roads = roads;
    return this.roads.setDefault("color", this.default_color);
  };

  Road.set_breed = function(patch, city_hall_dist) {
    if (city_hall_dist == null) {
      city_hall_dist = null;
    }
    this.roads.setBreed(patch);
    extend(patch, Road);
    return patch.init(city_hall_dist);
  };

  Road.prototype.init = function(city_hall_dist) {
    this._update_navigation();
    this._update_distances(0, city_hall_dist);
    if (RoadNode.check_patch(this)) {
      RoadNode.spawn_node(this);
    }
    return null;
  };

  Road.prototype._update_navigation = function() {
    return CityModel.set_road_nav_patch_walkable(this);
  };

  Road.prototype._update_distances = function(dist_to_road, city_hall_dist) {
    this.dist_to_road = dist_to_road;
    if (city_hall_dist == null) {
      city_hall_dist = Road._get_min_neighbour(this, "dist_to_city_hall", {
        get_value: true
      }) + 1;
    }
    this._set_city_hall_dist(city_hall_dist);
    return this._update_patches_dist_to_road();
  };

  Road.prototype._update_patches_dist_to_road = function() {
    var n_road, new_distance, patch, patches_to_update, _i, _len, _ref, _ref1;
    patches_to_update = Road._get_patches_to_update(this, 0);
    while (patches_to_update.length > 0) {
      _ref = patches_to_update.pop(), patch = _ref[0], new_distance = _ref[1];
      patch.dist_to_road = new_distance;
      _ref1 = Road._get_patches_to_update(patch, new_distance);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        n_road = _ref1[_i];
        patches_to_update.push(n_road);
      }
    }
    return null;
  };

  Road.prototype._set_city_hall_dist = function(dist_to_city_hall) {
    var n_road, _has_to_update, _i, _len, _ref, _results;
    this.dist_to_city_hall = dist_to_city_hall;
    _has_to_update = function(road) {
      if (road.dist_to_city_hall == null) {
        return true;
      } else {
        return road.dist_to_city_hall > dist_to_city_hall + 1;
      }
    };
    _ref = this.n4;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_road = _ref[_i];
      if (Road.is_road(n_road)) {
        if (_has_to_update(n_road)) {
          _results.push(n_road._set_city_hall_dist(dist_to_city_hall + 1));
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  Road._get_patches_to_update = function(patch, new_distance) {
    var n_patch, to_update, _i, _len, _ref;
    to_update = [];
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_patch = _ref[_i];
      if ((n_patch.dist_to_road == null) || n_patch.dist_to_road > new_distance + 1) {
        to_update.push([n_patch, new_distance + 1]);
      }
    }
    return to_update;
  };

  Road.recalculate_distances = function() {
    var road, _i, _len, _ref, _results;
    _ref = this.roads;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      road = _ref[_i];
      _results.push(this._update_distances(road, 0, null));
    }
    return _results;
  };

  Road._spread_connectivity = function(patch) {
    var n_patch, new_distance, _i, _len, _ref;
    new_distance = patch.dist_to_road + 1;
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_patch = _ref[_i];
      if ((n_patch.dist_to_road == null) || n_patch.dist_to_road > new_distance) {
        this._set_distance_to_road(n_patch, new_distance);
      }
    }
    return null;
  };

  Road.is_road = function(patch) {
    return patch.breed === this.roads;
  };

  Road.get_closest_road_to = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    while (patch.dist_to_road !== 0) {
      patch = this._get_min_neighbour(patch, "dist_to_road", {});
    }
    return patch;
  };

  Road.is_too_connected = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    return patch.dist_to_road <= Road.too_connected_threshold;
  };

  Road._get_min_neighbour = function(patch, param, _arg) {
    var filter, get_value, min_patch, neighbour, neighbours, _i, _len, _ref;
    get_value = _arg.get_value, filter = _arg.filter, neighbours = _arg.neighbours;
    if (get_value == null) {
      get_value = false;
    }
    if (filter == null) {
      filter = (function() {
        return true;
      });
    }
    if (neighbours == null) {
      neighbours = (function(p) {
        return p.n4;
      });
    }
    min_patch = patch;
    _ref = neighbours(patch);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      neighbour = _ref[_i];
      if (filter(neighbour)) {
        if ((min_patch[param] == null) || neighbour[param] < min_patch[param]) {
          min_patch = neighbour;
        }
      }
    }
    if (get_value) {
      return min_patch[param];
    } else {
      return min_patch;
    }
  };

  Road._get_max_neighbour = function(patch, param, _arg) {
    var filter, get_value, max_patch, neighbour, neighbours, _i, _len, _ref;
    get_value = _arg.get_value, filter = _arg.filter, neighbours = _arg.neighbours;
    if (get_value == null) {
      get_value = false;
    }
    if (filter == null) {
      filter = (function() {
        return true;
      });
    }
    if (neighbours == null) {
      neighbours = (function(p) {
        return p.n4;
      });
    }
    max_patch = patch;
    _ref = neighbours(patch);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      neighbour = _ref[_i];
      if (filter(neighbour)) {
        if ((max_patch[param] == null) || neighbour[param] > max_patch[param]) {
          max_patch = neighbour;
        }
      }
    }
    if (get_value) {
      return max_patch[param];
    } else {
      return max_patch;
    }
  };

  Road.add_road_node = function(road) {
    return this.road_nodes.push(road);
  };

  Road._get_distance = function(road_a, road_b) {
    var dx, dy;
    dx = Math.abd(road_a.x, road_b.x);
    dy = Math.abd(road_a.y, road_b.y);
    return dx + dy;
  };

  Road.get_road_distance = function(road_a, road_b) {
    return CityModel.instance.roadAStar.getPath(road_a, road_b).length;
  };

  Road.get_connectivity = function(patch) {
    return patch.dist_to_road;
  };

  Road.get_road_neighbours = function(patch) {
    var road;
    return (function() {
      var _i, _len, _ref, _results;
      _ref = patch.n4;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        road = _ref[_i];
        if (Road.is_road(road)) {
          _results.push(road);
        }
      }
      return _results;
    })();
  };

  return Road;

})();

CityModel.register_module(Road, [], ['roads']);

RoadNode = (function() {
  function RoadNode() {}

  RoadNode.breed_name = 'road_nodes';

  RoadNode.road_nodes = null;

  RoadNode.default_color = [160, 160, 160];

  RoadNode.initialize = function(road_nodes) {
    this.road_nodes = road_nodes;
    this.road_nodes.setDefault('color', this.default_color);
    this.road_nodes.setDefault('shape', 'circle');
    return this.road_nodes.setDefault('size', 0.4);
  };

  RoadNode.check_patch = function(patch) {
    return Road.is_road(patch) && (patch.node == null);
  };

  RoadNode.spawn_node = function(patch) {
    var node;
    node = RoadNode._make_node(patch);
    RoadNode._prepare_neighbour_roads(patch);
    node.connect();
    return node;
  };

  RoadNode.split_link_at = function(road) {
    var node, node_a, node_b, _ref;
    _ref = RoadNode._get_nodes_connecting(road), node_a = _ref[0], node_b = _ref[1];
    RoadNode._remove_link_between(node_a, node_b);
    node = RoadNode._make_node(road);
    node.creating = false;
    CityModel.link_agents(node_a, node);
    return CityModel.link_agents(node, node_b);
  };

  RoadNode._make_node = function(road) {
    var new_node;
    new_node = road.sprout(1, this.road_nodes)[0];
    extend(new_node, RoadNode);
    road.node = new_node;
    return new_node;
  };

  RoadNode._prepare_neighbour_roads = function(road) {
    var n_road, _i, _len, _ref, _results;
    _ref = road.n4;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_road = _ref[_i];
      if (Road.is_road(n_road) && (n_road.node == null)) {
        _results.push(RoadNode.split_link_at(n_road));
      }
    }
    return _results;
  };

  RoadNode._get_nodes_connecting = function(road) {
    var a_dir, b_dir, neighbour_roads, road_a, road_b, _ref, _ref1;
    neighbour_roads = Road.get_road_neighbours(road);
    _ref = this._get_aligned_patches(neighbour_roads), road_a = _ref[0], road_b = _ref[1];
    _ref1 = this._get_direction(road_a, road_b), a_dir = _ref1[0], b_dir = _ref1[1];
    while (road_a.node == null) {
      road_a = this._get_neighbour_with_offset(road_a, a_dir);
    }
    while (road_b.node == null) {
      road_b = this._get_neighbour_with_offset(road_b, b_dir);
    }
    return [road_a.node, road_b.node];
  };

  RoadNode._get_aligned_patches = function(patches) {
    if (this._are_aligned(patches[0], patches[1])) {
      return [patches[0], patches[1]];
    } else if (this._are_aligned(patches[1], patches[2])) {
      return [patches[1], patches[2]];
    } else {
      return [patches[0], patches[2]];
    }
  };

  RoadNode._are_aligned = function(patch_a, patch_b) {
    return patch_a.x === patch_b.x || patch_a.y === patch_b.y;
  };

  RoadNode._get_direction = function(patch_a, patch_b) {
    var dx, dy;
    dx = (patch_a.x - patch_b.x) / 2;
    dy = (patch_a.y - patch_b.y) / 2;
    return [
      {
        x: dx,
        y: dy
      }, {
        x: -dx,
        y: -dy
      }
    ];
  };

  RoadNode._get_neighbour_with_offset = function(patch, offset) {
    var n, _i, _len, _ref;
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n.x === patch.x + offset.x && n.y === patch.y + offset.y) {
        return n;
      }
    }
  };

  RoadNode._remove_link_between = function(node_a, node_b) {
    var link, _i, _len, _ref;
    _ref = node_a.myLinks();
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      if (link.otherEnd(node_a) === node_b) {
        link.die();
      }
    }
    return null;
  };

  RoadNode.prototype.creating = true;

  RoadNode.prototype.step = function() {};

  RoadNode.prototype.connect = function() {
    if (this._any_neighbours_nodes()) {
      this._connect_to_neighbours();
      this._smooth_neighbours();
    }
    return this.creating = false;
  };

  RoadNode.prototype._connect_to_neighbours = function() {
    var neighbour_nodes, node, _i, _len, _results;
    neighbour_nodes = this._get_node_neighbours();
    _results = [];
    for (_i = 0, _len = neighbour_nodes.length; _i < _len; _i++) {
      node = neighbour_nodes[_i];
      _results.push(CityModel.link_agents(this, node));
    }
    return _results;
  };

  RoadNode.prototype._any_neighbours_nodes = function() {
    return this._get_node_neighbours().length > 0;
  };

  RoadNode.prototype._smooth_neighbours = function() {
    var node, nodes, _i, _len, _results;
    nodes = this._get_node_neighbours();
    nodes.push(this);
    _results = [];
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      node = nodes[_i];
      _results.push(node._smooth_node());
    }
    return _results;
  };

  RoadNode.prototype._get_node_neighbours = function() {
    var patch;
    return (function() {
      var _i, _len, _ref, _results;
      _ref = this.p.n4;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        patch = _ref[_i];
        if (patch.node != null) {
          _results.push(patch.node);
        }
      }
      return _results;
    }).call(this);
  };

  RoadNode.prototype._is_aligned_with = function(node) {
    return this.p.x === node.p.x || this.p.y === node.p.y;
  };

  RoadNode.prototype._smooth_node = function() {
    var neighbours, node_a, node_b;
    neighbours = this.linkNeighbors();
    if (neighbours.length === 2) {
      node_a = neighbours[0], node_b = neighbours[1];
      if (node_a._is_aligned_with(node_b)) {
        CityModel.link_agents(node_a, node_b);
        this.p.node = null;
        return this.die();
      }
    }
  };

  return RoadNode;

})();

CityModel.register_module(RoadNode, ['road_nodes'], []);
