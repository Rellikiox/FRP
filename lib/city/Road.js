// Generated by CoffeeScript 1.7.1
var Road, RoadNode, RoadNode_instance_properties;

Road = (function() {
  function Road() {}

  Road.roads = null;

  Road.default_color = [80, 80, 80];

  Road.too_connected_threshold = 2;

  Road.road_nodes = [];

  Road.initialize_module = function(patches, road_breed) {
    this.roads = road_breed;
    this.roads.setDefault("color", this.default_color);
    return patches.setDefault("dist_to_road", null);
  };

  Road.set_breed = function(patch, city_hall_dist) {
    var node;
    if (city_hall_dist == null) {
      city_hall_dist = null;
    }
    this.roads.setBreed(patch);
    CityModel.instance.roadAStar.setWalkable(patch);
    this._update_distances(patch, 0, city_hall_dist);
    if (RoadNode.check_patch(patch)) {
      node = RoadNode.spawn_node(patch);
      patch.node = node;
    }
    return null;
  };

  Road.recalculate_distances = function() {
    var road, _i, _len, _ref, _results;
    _ref = this.roads;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      road = _ref[_i];
      _results.push(this._update_distances(road, 0, null));
    }
    return _results;
  };

  Road._update_distances = function(patch, dist_to_road, city_hall_dist) {
    var n_road, new_distance, road, roads_to_update, _i, _len, _ref, _ref1;
    if (city_hall_dist == null) {
      city_hall_dist = this._get_min_neighbour(patch, "dist_to_city_hall", {
        get_value: true
      }) + 1;
    }
    patch.dist_to_road = dist_to_road;
    this._set_city_hall_dist(patch, city_hall_dist);
    roads_to_update = this._get_roads_to_update(patch, 0);
    while (roads_to_update.length > 0) {
      _ref = roads_to_update.pop(), road = _ref[0], new_distance = _ref[1];
      road.dist_to_road = new_distance;
      _ref1 = this._get_roads_to_update(road, new_distance);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        n_road = _ref1[_i];
        roads_to_update.push(n_road);
      }
    }
    return null;
  };

  Road._set_city_hall_dist = function(road, dist_to_city_hall) {
    var n_road, _i, _len, _ref, _results;
    road.dist_to_city_hall = dist_to_city_hall;
    road.label = road.dist_to_city_hall;
    _ref = road.n4;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_road = _ref[_i];
      if (n_road.breed === this.roads) {
        if ((n_road.dist_to_city_hall == null) || n_road.dist_to_city_hall > dist_to_city_hall + 1) {
          _results.push(this._set_city_hall_dist(n_road, dist_to_city_hall + 1));
        } else {
          _results.push(void 0);
        }
      }
    }
    return _results;
  };

  Road._get_roads_to_update = function(road, new_distance) {
    var n_road, to_update, _i, _len, _ref;
    to_update = [];
    _ref = road.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_road = _ref[_i];
      if ((n_road.dist_to_road == null) || n_road.dist_to_road > new_distance + 1) {
        to_update.push([n_road, new_distance + 1]);
      }
    }
    return to_update;
  };

  Road._spread_connectivity = function(patch) {
    var n_patch, new_distance, _i, _len, _ref;
    new_distance = patch.dist_to_road + 1;
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_patch = _ref[_i];
      if ((n_patch.dist_to_road == null) || n_patch.dist_to_road > new_distance) {
        this._set_distance_to_road(n_patch, new_distance);
      }
    }
    return null;
  };

  Road.is_road_here = function(patch) {
    return patch.breed === this.roads;
  };

  Road.get_closest_road_to = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    while (patch.dist_to_road !== 0) {
      patch = this._get_min_neighbour(patch, "dist_to_road", {});
    }
    return patch;
  };

  Road.is_too_connected = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    return patch.dist_to_road <= Road.too_connected_threshold;
  };

  Road._get_min_neighbour = function(patch, param, _arg) {
    var filter, get_value, min_patch, neighbour, neighbours, _i, _len, _ref;
    get_value = _arg.get_value, filter = _arg.filter, neighbours = _arg.neighbours;
    if (get_value == null) {
      get_value = false;
    }
    if (filter == null) {
      filter = (function() {
        return true;
      });
    }
    if (neighbours == null) {
      neighbours = (function(p) {
        return p.n4;
      });
    }
    min_patch = patch;
    _ref = neighbours(patch);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      neighbour = _ref[_i];
      if (filter(neighbour)) {
        if ((min_patch[param] == null) || neighbour[param] < min_patch[param]) {
          min_patch = neighbour;
        }
      }
    }
    if (get_value) {
      return min_patch[param];
    } else {
      return min_patch;
    }
  };

  Road.add_road_node = function(road) {
    return this.road_nodes.push(road);
  };

  Road._get_distance = function(road_a, road_b) {
    var dx, dy;
    dx = Math.abd(road_a.x, road_b.x);
    dy = Math.abd(road_a.y, road_b.y);
    return dx + dy;
  };

  return Road;

})();

RoadNode = (function() {
  function RoadNode() {}

  RoadNode.road_nodes = null;

  RoadNode.default_color = [160, 160, 160];

  RoadNode.initialize_module = function(road_nodes_breed) {
    this.road_nodes = road_nodes_breed;
    this.road_nodes.setDefault('color', this.default_color);
    this.road_nodes.setDefault('shape', 'circle');
    return this.road_nodes.setDefault('size', 0.4);
  };

  RoadNode.check_patch = function(patch) {
    var neighbour_roads;
    if (!Road.is_road_here(patch)) {
      return;
    }
    neighbour_roads = this._get_road_neighbours(patch);
    return !(neighbour_roads.length === 2 && this._patches_are_aligned(neighbour_roads[0], neighbour_roads[1]));
  };

  RoadNode._patches_are_aligned = function(patch_a, patch_b) {
    return patch_a.x === patch_b.x || patch_a.y === patch_b.y;
  };

  RoadNode._get_road_neighbours = function(patch) {
    var road;
    return (function() {
      var _i, _len, _ref, _results;
      _ref = patch.n4;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        road = _ref[_i];
        if (Road.is_road_here(road)) {
          _results.push(road);
        }
      }
      return _results;
    })();
  };

  RoadNode.spawn_node = function(patch) {
    var node;
    node = patch.sprout(1, this.road_nodes)[0];
    extend(node, RoadNode_instance_properties);
    node.connect_to_network();
    return node;
  };

  return RoadNode;

})();

RoadNode_instance_properties = {
  connect_to_network: function() {
    var node, nodes, _i, _len, _results;
    nodes = this._get_node_neighbours();
    if ((nodes != null ? nodes.length : void 0) > 0) {
      this.connect_to_neighbours(nodes);
      nodes.push(this);
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        node = nodes[_i];
        _results.push(node.smooth_neighbours());
      }
      return _results;
    } else {
      return null;
    }
  },
  connect_to_neighbours: function(neighbour_nodes) {
    var node, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = neighbour_nodes.length; _i < _len; _i++) {
      node = neighbour_nodes[_i];
      _results.push(CityModel.link_agents(this, node));
    }
    return _results;
  },
  smooth_neighbours: function() {
    var neighbours, node_a, node_b;
    neighbours = this.linkNeighbors();
    if (neighbours.length === 2) {
      node_a = neighbours[0], node_b = neighbours[1];
      if (RoadNode._patches_are_aligned(node_a.p, node_b.p)) {
        this.die();
        return CityModel.link_agents(node_a, node_b);
      }
    }
  },
  _get_node_neighbours: function() {
    var patch;
    return (function() {
      var _i, _len, _ref, _results;
      _ref = this.p.n4;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        patch = _ref[_i];
        if (patch.node != null) {
          _results.push(patch.node);
        }
      }
      return _results;
    }).call(this);
  }
};
