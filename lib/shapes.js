// Generated by CoffeeScript 1.7.1
var __hasProp = {}.hasOwnProperty;

ABM.shapes = ABM.util.s = (function() {
  var ccirc, cimg, circ, csq, fillSlot, poly, spriteSheets;
  poly = function(c, a) {
    var i, p, _i, _len;
    for (i = _i = 0, _len = a.length; _i < _len; i = ++_i) {
      p = a[i];
      if (i === 0) {
        c.moveTo(p[0], p[1]);
      } else {
        c.lineTo(p[0], p[1]);
      }
    }
    return null;
  };
  circ = function(c, x, y, s) {
    return c.arc(x, y, s / 2, 0, 2 * Math.PI);
  };
  ccirc = function(c, x, y, s) {
    return c.arc(x, y, s / 2, 0, 2 * Math.PI, true);
  };
  cimg = function(c, x, y, s, img) {
    c.scale(1, -1);
    c.drawImage(img, x - s / 2, y - s / 2, s, s);
    return c.scale(1, -1);
  };
  csq = function(c, x, y, s) {
    return c.fillRect(x - s / 2, y - s / 2, s, s);
  };
  fillSlot = function(slot, img) {
    slot.ctx.save();
    slot.ctx.scale(1, -1);
    slot.ctx.drawImage(img, slot.x, -(slot.y + slot.bits), slot.bits, slot.bits);
    return slot.ctx.restore();
  };
  spriteSheets = [];
  return {
    "default": {
      rotate: true,
      draw: function(c) {
        return poly(c, [[.5, 0], [-.5, -.5], [-.25, 0], [-.5, .5]]);
      }
    },
    triangle: {
      rotate: true,
      draw: function(c) {
        return poly(c, [[.5, 0], [-.5, -.4], [-.5, .4]]);
      }
    },
    arrow: {
      rotate: true,
      draw: function(c) {
        return poly(c, [[.5, 0], [0, .5], [0, .2], [-.5, .2], [-.5, -.2], [0, -.2], [0, -.5]]);
      }
    },
    bug: {
      rotate: true,
      draw: function(c) {
        c.strokeStyle = c.fillStyle;
        c.lineWidth = .05;
        poly(c, [[.4, .225], [.2, 0], [.4, -.225]]);
        c.stroke();
        c.beginPath();
        circ(c, .12, 0, .26);
        circ(c, -.05, 0, .26);
        return circ(c, -.27, 0, .4);
      }
    },
    pyramid: {
      rotate: false,
      draw: function(c) {
        return poly(c, [[0, .5], [-.433, -.25], [.433, -.25]]);
      }
    },
    circle: {
      shortcut: function(c, x, y, s) {
        c.beginPath();
        circ(c, x, y, s);
        c.closePath();
        return c.fill();
      },
      rotate: false,
      draw: function(c) {
        return circ(c, 0, 0, 1);
      }
    },
    square: {
      shortcut: function(c, x, y, s) {
        return csq(c, x, y, s);
      },
      rotate: false,
      draw: function(c) {
        return csq(c, 0, 0, 1);
      }
    },
    pentagon: {
      rotate: false,
      draw: function(c) {
        return poly(c, [[0, .45], [-.45, .1], [-.3, -.45], [.3, -.45], [.45, .1]]);
      }
    },
    ring: {
      rotate: false,
      draw: function(c) {
        circ(c, 0, 0, 1);
        c.closePath();
        return ccirc(c, 0, 0, .6);
      }
    },
    person: {
      rotate: false,
      draw: function(c) {
        poly(c, [[.15, .2], [.3, 0], [.125, -.1], [.125, .05], [.1, -.15], [.25, -.5], [.05, -.5], [0, -.25], [-.05, -.5], [-.25, -.5], [-.1, -.15], [-.125, .05], [-.125, -.1], [-.3, 0], [-.15, .2]]);
        c.closePath();
        return circ(c, 0, .35, .30);
      }
    },
    names: function() {
      var name, val, _results;
      _results = [];
      for (name in this) {
        if (!__hasProp.call(this, name)) continue;
        val = this[name];
        if ((val.rotate != null) && (val.draw != null)) {
          _results.push(name);
        }
      }
      return _results;
    },
    add: function(name, rotate, draw, shortcut) {
      var s;
      s = this[name] = u.isFunction(draw) ? {
        rotate: rotate,
        draw: draw
      } : {
        rotate: rotate,
        img: draw,
        draw: function(c) {
          return cimg(c, .5, .5, 1, this.img);
        }
      };
      if ((s.img != null) && !s.rotate) {
        s.shortcut = function(c, x, y, s) {
          return cimg(c, x, y, s, this.img);
        };
      }
      if (shortcut != null) {
        return s.shortcut = shortcut;
      }
    },
    poly: poly,
    circ: circ,
    ccirc: ccirc,
    cimg: cimg,
    csq: csq,
    spriteSheets: spriteSheets,
    draw: function(ctx, shape, x, y, size, rad, color) {
      if (shape.shortcut != null) {
        if (shape.img == null) {
          ctx.fillStyle = u.colorStr(color);
        }
        shape.shortcut(ctx, x, y, size);
      } else {
        ctx.save();
        ctx.translate(x, y);
        if (size !== 1) {
          ctx.scale(size, size);
        }
        if (rad !== 0) {
          ctx.rotate(rad);
        }
        if (shape.img != null) {
          shape.draw(ctx);
        } else {
          ctx.fillStyle = u.colorStr(color);
          ctx.beginPath();
          shape.draw(ctx);
          ctx.closePath();
          ctx.fill();
        }
        ctx.restore();
      }
      return shape;
    },
    drawSprite: function(ctx, s, x, y, size, rad) {
      if (rad === 0) {
        ctx.drawImage(s.ctx.canvas, s.x, s.y, s.bits, s.bits, x - size / 2, y - size / 2, size, size);
      } else {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rad);
        ctx.drawImage(s.ctx.canvas, s.x, s.y, s.bits, s.bits, -size / 2, -size / 2, size, size);
        ctx.restore();
      }
      return s;
    },
    shapeToSprite: function(name, color, size) {
      var bits, ctx, foundSlot, img, index, shape, slot, x, y;
      bits = Math.ceil(ABM.patches.toBits(size));
      shape = this[name];
      index = shape.img != null ? name : "" + name + "-" + (u.colorStr(color));
      ctx = spriteSheets[bits];
      if (ctx == null) {
        spriteSheets[bits] = ctx = u.createCtx(bits * 10, bits);
        ctx.nextX = 0;
        ctx.nextY = 0;
        ctx.index = {};
      }
      if ((foundSlot = ctx.index[index]) != null) {
        return foundSlot;
      }
      if (bits * ctx.nextX === ctx.canvas.width) {
        u.resizeCtx(ctx, ctx.canvas.width, ctx.canvas.height + bits);
        ctx.nextX = 0;
        ctx.nextY++;
      }
      x = bits * ctx.nextX;
      y = bits * ctx.nextY;
      slot = {
        ctx: ctx,
        x: x,
        y: y,
        size: size,
        bits: bits,
        name: name,
        color: color,
        index: index
      };
      ctx.index[index] = slot;
      if ((img = shape.img) != null) {
        if (img.height !== 0) {
          fillSlot(slot, img);
        } else {
          img.onload = function() {
            return fillSlot(slot, img);
          };
        }
      } else {
        ctx.save();
        ctx.scale(bits, bits);
        ctx.translate(ctx.nextX + .5, ctx.nextY + .5);
        ctx.fillStyle = u.colorStr(color);
        ctx.beginPath();
        shape.draw(ctx);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
      ctx.nextX++;
      return slot;
    }
  };
})();
