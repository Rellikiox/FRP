// Generated by CoffeeScript 1.7.1
var Road;

Road = (function() {
  function Road() {}

  Road.roads = null;

  Road.default_color = [80, 80, 80];

  Road.too_connected_threshold = 3;

  Road.initialize_module = function(patches, road_breed) {
    this.roads = road_breed;
    this.roads.setDefault("color", this.default_color);
    return patches.setDefault("road_distance", null);
  };

  Road.makeHere = function(patch) {
    this.roads.setBreed(patch);
    CityModel.instance.roadAStar.setWalkable(patch);
    this._update_distance(patch, 0);
    return null;
  };

  Road.recalculate_distances = function() {
    var road, _i, _len, _ref, _results;
    _ref = this.roads;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      road = _ref[_i];
      _results.push(this._update_distance(road, 0));
    }
    return _results;
  };

  Road._update_distance = function(patch, road_distance) {
    var n_road, new_distance, road, roads_to_update, _i, _len, _ref, _ref1;
    patch.road_distance = road_distance;
    roads_to_update = this._get_roads_to_update(patch, 0);
    while (roads_to_update.length > 0) {
      _ref = roads_to_update.pop(), road = _ref[0], new_distance = _ref[1];
      road.road_distance = new_distance;
      _ref1 = this._get_roads_to_update(road, new_distance);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        n_road = _ref1[_i];
        roads_to_update.push(n_road);
      }
    }
    return null;
  };

  Road._get_roads_to_update = function(road, new_distance) {
    var n_road, to_update, _i, _len, _ref;
    to_update = [];
    _ref = road.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_road = _ref[_i];
      if ((n_road.road_distance == null) || n_road.road_distance > new_distance + 1) {
        to_update.push([n_road, new_distance + 1]);
      }
    }
    return to_update;
  };

  Road._spread_connectivity = function(patch) {
    var n_patch, new_distance, _i, _len, _ref;
    new_distance = patch.road_distance + 1;
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_patch = _ref[_i];
      if ((n_patch.road_distance == null) || n_patch.road_distance > new_distance) {
        this._set_distance_to_road(n_patch, new_distance);
      }
    }
    return null;
  };

  Road.is_road_here = function(patch) {
    return patch.breed === this.roads;
  };

  Road.get_closest_road_to = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    while (patch.road_distance !== 0) {
      patch = this._get_min_neighbour(patch);
    }
    return patch;
  };

  Road.is_too_connected = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    return patch.road_distance <= Road.too_connected_threshold;
  };

  Road._get_min_neighbour = function(patch) {
    var min_patch, neighbour, _i, _len, _ref;
    min_patch = patch;
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      neighbour = _ref[_i];
      if (neighbour.road_distance < min_patch.road_distance) {
        min_patch = neighbour;
      }
    }
    return min_patch;
  };

  return Road;

})();
