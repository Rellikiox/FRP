// Generated by CoffeeScript 1.7.1
var Road;

Road = (function() {
  function Road() {}

  Road.roads = null;

  Road.default_color = [80, 80, 80];

  Road.too_connected_threshold = 2;

  Road.initialize_module = function(patches, road_breed) {
    this.roads = road_breed;
    this.roads.setDefault("color", this.default_color);
    return patches.setDefault("dist_to_road", null);
  };

  Road.makeHere = function(patch) {
    this.roads.setBreed(patch);
    CityModel.instance.roadAStar.setWalkable(patch);
    this._update_distances(patch, 0);
    return null;
  };

  Road.recalculate_distances = function() {
    var road, _i, _len, _ref, _results;
    _ref = this.roads;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      road = _ref[_i];
      _results.push(this._update_distances(road, 0));
    }
    return _results;
  };

  Road._update_distances = function(patch, dist_to_road) {
    var n_road, new_distance, road, roads_to_update, _i, _len, _ref, _ref1;
    patch.dist_to_road = dist_to_road;
    this._set_city_hall_dist(patch, this._get_min_neighbour(patch, (function(p) {
      return p.n4;
    }), "dist_to_city_hall", true) + 1);
    roads_to_update = this._get_roads_to_update(patch, 0);
    while (roads_to_update.length > 0) {
      _ref = roads_to_update.pop(), road = _ref[0], new_distance = _ref[1];
      road.dist_to_road = new_distance;
      _ref1 = this._get_roads_to_update(road, new_distance);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        n_road = _ref1[_i];
        roads_to_update.push(n_road);
      }
    }
    return null;
  };

  Road._set_city_hall_dist = function(road, dist_to_city_hall) {
    road.dist_to_city_hall = dist_to_city_hall;
    return road.label = road.dist_to_city_hall;
  };

  Road._get_roads_to_update = function(road, new_distance) {
    var n_road, to_update, _i, _len, _ref;
    to_update = [];
    _ref = road.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_road = _ref[_i];
      if ((n_road.dist_to_road == null) || n_road.dist_to_road > new_distance + 1) {
        to_update.push([n_road, new_distance + 1]);
      }
    }
    return to_update;
  };

  Road._spread_connectivity = function(patch) {
    var n_patch, new_distance, _i, _len, _ref;
    new_distance = patch.dist_to_road + 1;
    _ref = patch.n4;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n_patch = _ref[_i];
      if ((n_patch.dist_to_road == null) || n_patch.dist_to_road > new_distance) {
        this._set_distance_to_road(n_patch, new_distance);
      }
    }
    return null;
  };

  Road.is_road_here = function(patch) {
    return patch.breed === this.roads;
  };

  Road.get_closest_road_to = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    while (patch.dist_to_road !== 0) {
      patch = this._get_min_neighbour(patch, (function(p) {
        return p.n4;
      }), "dist_to_road");
    }
    return patch;
  };

  Road.is_too_connected = function(point) {
    var patch;
    patch = CityModel.get_patch_at(point);
    return patch.dist_to_road <= Road.too_connected_threshold;
  };

  Road._get_min_neighbour = function(patch, neighbours, param, get_value) {
    var min_patch, neighbour, _i, _len, _ref;
    if (get_value == null) {
      get_value = false;
    }
    min_patch = patch;
    _ref = neighbours(patch);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      neighbour = _ref[_i];
      if ((min_patch[param] == null) || neighbour[param] < min_patch[param]) {
        min_patch = neighbour;
      }
    }
    if (get_value) {
      return min_patch[param];
    } else {
      return min_patch;
    }
  };

  return Road;

})();
